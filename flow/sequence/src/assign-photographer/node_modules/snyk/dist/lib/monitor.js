"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const snyk = require("../lib");
const api_token_1 = require("./api-token");
const request = require("./request");
const config = require("./config");
const os = require("os");
const _ = require("lodash");
const is_ci_1 = require("./is-ci");
const analytics = require("./analytics");
const types_1 = require("./types");
const projectMetadata = require("./project-metadata");
const path = require("path");
function monitor(root, meta, info, targetFile) {
    const pkg = info.package;
    const pluginMeta = info.plugin;
    let policyPath = meta['policy-path'];
    if (!meta.isDocker) {
        policyPath = policyPath || root;
    }
    const policyLocations = [policyPath].concat(pluckPolicies(pkg))
        .filter(Boolean);
    const opts = { loose: true };
    const packageManager = meta.packageManager || 'npm';
    return api_token_1.exists('snyk monitor')
        .then(() => {
        if (policyLocations.length === 0) {
            return snyk.policy.create();
        }
        return snyk.policy.load(policyLocations, opts);
    }).then((policy) => __awaiter(this, void 0, void 0, function* () {
        analytics.add('packageManager', packageManager);
        const target = yield projectMetadata.getInfo(pkg);
        const targetFileRelativePath = targetFile ? path.relative(root, targetFile) : '';
        if (target && target.branch) {
            analytics.add('targetBranch', target.branch);
        }
        // TODO(kyegupov): async/await
        return new Promise((resolve, reject) => {
            request({
                body: {
                    meta: {
                        method: meta.method,
                        hostname: os.hostname(),
                        id: meta.id || snyk.id || pkg.name,
                        ci: is_ci_1.isCI(),
                        pid: process.pid,
                        node: process.version,
                        master: snyk.config.isMaster,
                        name: pkg.name,
                        version: pkg.version,
                        org: config.org ? decodeURIComponent(config.org) : undefined,
                        pluginName: pluginMeta.name,
                        pluginRuntime: pluginMeta.runtime,
                        dockerImageId: pluginMeta.dockerImageId,
                        dockerBaseImage: pkg.docker ? pkg.docker.baseImage : undefined,
                        dockerfileLayers: pkg.docker ? pkg.docker.dockerfileLayers : undefined,
                        projectName: meta['project-name'],
                    },
                    policy: policy ? policy.toString() : undefined,
                    package: pkg,
                    // we take the targetFile from the plugin,
                    // because we want to send it only for specific package-managers
                    target,
                    targetFile: pluginMeta.targetFile,
                    targetFileRelativePath,
                },
                gzip: true,
                method: 'PUT',
                headers: {
                    'authorization': 'token ' + snyk.api,
                    'content-encoding': 'gzip',
                },
                url: config.API + '/monitor/' + packageManager,
                json: true,
            }, (error, res, body) => {
                if (error) {
                    return reject(error);
                }
                if (res.statusCode === 200 || res.statusCode === 201) {
                    resolve(body);
                }
                else {
                    const e = new types_1.MonitorError('Server returned unexpected error for the monitor request. ' +
                        `Status code: ${res.statusCode}, response: ${res.body.userMessage || res.body.message}`);
                    e.code = res.statusCode;
                    e.userMessage = body && body.userMessage;
                    if (!e.userMessage && res.statusCode === 504) {
                        e.userMessage = 'Connection Timeout';
                    }
                    reject(e);
                }
            });
        });
    }));
}
exports.monitor = monitor;
function pluckPolicies(pkg) {
    if (!pkg) {
        return null;
    }
    if (pkg.snyk) {
        return pkg.snyk;
    }
    if (!pkg.dependencies) {
        return null;
    }
    return _.flatten(Object.keys(pkg.dependencies).map((name) => {
        return pluckPolicies(pkg.dependencies[name]);
    }).filter(Boolean));
}
//# sourceMappingURL=monitor.js.map