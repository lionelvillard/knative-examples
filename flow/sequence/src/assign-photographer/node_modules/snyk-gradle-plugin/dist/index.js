"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const os = require("os");
const fs = require("fs");
const path = require("path");
const subProcess = require("./sub-process");
const tmp = require("tmp");
const errors_1 = require("./errors");
const chalk_1 = require("chalk");
const debugModule = require("debug");
// To enable debugging output, run the CLI as `DEBUG=snyk-gradle-plugin snyk ...`
let logger = null;
function debugLog(s) {
    if (logger === null) {
        // Lazy init: Snyk CLI needs to process the CLI argument "-d" first.
        // TODO(BST-648): more robust handling of the debug settings
        if (process.env.DEBUG) {
            debugModule.enable(process.env.DEBUG);
        }
        logger = debugModule('snyk-gradle-plugin');
    }
    logger(s);
}
const packageFormatVersion = 'mvn:0.0.1';
function isMultiSubProject(options) {
    return options.multiDepRoots;
}
function inspect(root, targetFile, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!options) {
            options = { dev: false };
        }
        let subProject = options['gradle-sub-project'];
        if (subProject) {
            subProject = subProject.trim();
        }
        const plugin = {
            name: 'bundled:gradle',
            runtime: 'unknown',
            targetFile: targetFileFilteredForCompatibility(targetFile),
        };
        if (isMultiSubProject(options)) {
            if (subProject) {
                throw new Error('gradle-sub-project flag is incompatible with multiDepRoots');
            }
            return {
                plugin,
                depRoots: yield getAllDepsAllProjects(root, targetFile, options),
            };
        }
        const depTreeAndDepRootNames = yield getAllDepsOneProject(root, targetFile, options, subProject);
        if (depTreeAndDepRootNames.allSubProjectNames) {
            plugin.meta = plugin.meta || {};
            plugin.meta.allSubProjectNames = depTreeAndDepRootNames.allSubProjectNames;
        }
        return {
            plugin,
            package: depTreeAndDepRootNames.depTree,
        };
    });
}
exports.inspect = inspect;
// See the comment for DepRoot.targetFile
// Note: for Gradle, we are not returning the name unless it's a .kts file.
// This is a workaround for a project naming problem happening in Registry
// (legacy projects are named without "build.gradle" attached to them).
// See ticket BST-529 re permanent solution.
function targetFileFilteredForCompatibility(targetFile) {
    return (path.basename(targetFile) === 'build.gradle.kts') ? targetFile : undefined;
}
function extractJsonFromScriptOutput(stdoutText) {
    const lines = stdoutText.split('\n');
    let jsonLine = null;
    lines.forEach((l) => {
        if (/^JSONDEPS /.test(l)) {
            if (jsonLine !== null) {
                throw new Error('More than one line with "JSONDEPS " prefix was returned; full output:\n' + stdoutText);
            }
            jsonLine = l.substr(9);
        }
    });
    if (jsonLine === null) {
        throw new Error('No line prefixed with "JSONDEPS " was returned; full output:\n' + stdoutText);
    }
    return JSON.parse(jsonLine);
}
function getAllDepsOneProject(root, targetFile, options, subProject) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const packageName = path.basename(root);
        const allProjectDeps = yield getAllDeps(root, targetFile, options);
        const allSubProjectNames = allProjectDeps.allSubProjectNames;
        let depDict = {};
        if (subProject) {
            return {
                depTree: getDepsSubProject(root, subProject, allProjectDeps),
                allSubProjectNames,
            };
        }
        depDict = allProjectDeps.projects[allProjectDeps.defaultProject].depDict;
        return {
            depTree: {
                dependencies: depDict,
                name: packageName,
                // TODO: extract from project
                // https://snyksec.atlassian.net/browse/BST-558
                version: '0.0.0',
                packageFormatVersion,
            },
            allSubProjectNames,
        };
    });
}
function getDepsSubProject(root, subProject, allProjectDeps) {
    const packageName = `${path.basename(root)}/${subProject}`;
    let depDict = {};
    if (!allProjectDeps.projects || !allProjectDeps.projects[subProject]) {
        throw new errors_1.MissingSubProjectError(subProject, Object.keys(allProjectDeps));
    }
    depDict = allProjectDeps.projects[subProject].depDict;
    return {
        dependencies: depDict,
        name: packageName,
        // TODO: extract from project
        // https://snyksec.atlassian.net/browse/BST-558
        version: '0.0.0',
        packageFormatVersion,
    };
}
function getAllDepsAllProjects(root, targetFile, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const allProjectDeps = yield getAllDeps(root, targetFile, options);
        const basePackageName = path.basename(root);
        const packageVersion = '0.0.0';
        return Object.keys(allProjectDeps.projects).map((proj) => {
            const packageName = proj === allProjectDeps.defaultProject ? basePackageName : basePackageName + '/' + proj;
            return {
                targetFile: targetFileFilteredForCompatibility(allProjectDeps.projects[proj].targetFile),
                depTree: {
                    dependencies: allProjectDeps.projects[proj].depDict,
                    name: packageName,
                    version: packageVersion,
                    packageFormatVersion,
                },
            };
        });
    });
}
const reEcho = /^SNYKECHO (.*)$/;
function printIfEcho(line) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const maybeMatch = reEcho.exec(line);
        if (maybeMatch) {
            debugLog(maybeMatch[1]);
        }
    });
}
function getAllDeps(root, targetFile, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const args = buildArgs(root, targetFile, options.args);
        let tmpInitGradle = null;
        // TODO: move to buildArgs, adjust tests
        let initGradlePath = null;
        if (/index.js$/.test(__filename)) {
            // running from ./dist
            initGradlePath = path.join(__dirname, '../lib/init.gradle');
        }
        else if (/index.ts$/.test(__filename)) {
            // running from ./lib
            initGradlePath = path.join(__dirname, 'init.gradle');
        }
        else {
            throw new Error('Cannot locate Snyk init.gradle script');
        }
        // We could be running from a bundled CLI generated by `pkg`.
        // The Node filesystem in that case is not real: https://github.com/zeit/pkg#snapshot-filesystem
        // Copying the injectable script into a temp file.
        try {
            tmpInitGradle = tmp.fileSync({ postfix: '-init.gradle' });
            yield fs.createReadStream(initGradlePath).pipe(fs.createWriteStream('', { fd: tmpInitGradle.fd }));
            initGradlePath = tmpInitGradle.name;
        }
        catch (error) {
            error.message = error.message + '\n\n' +
                'Failed to create a temporary file to host Snyk init script for Gradle build analysis.';
            throw error;
        }
        if (!isMultiSubProject(options)) {
            args.push('-PonlySubProject=' + (options['gradle-sub-project'] || '.'));
        }
        args.push('-I ' + initGradlePath);
        // There might be a --configuration option in 'args'.
        // We need to convert it to a property: https://stackoverflow.com/a/48370451
        // TODO: (in snyk-cli) move `configuration` to `options`, disallow arbitrary args,
        // pin down `options` format via Typescript
        args.forEach((a, i) => {
            // Transform --configuration=foo
            args[i] = a.replace(/^--configuration[= ]/, '-Pconfiguration=');
            // Transform --configuration foo
            if (a === '--configuration') {
                args[i] = '-Pconfiguration=' + args[i + 1];
                args[i + 1] = '';
            }
        });
        const command = getCommand(root, targetFile);
        try {
            const stdoutText = yield subProcess.execute(command, args, { cwd: root }, printIfEcho);
            if (tmpInitGradle !== null) {
                tmpInitGradle.removeCallback();
            }
            return extractJsonFromScriptOutput(stdoutText);
        }
        catch (error) {
            // It'd be nice to set it in the inner catch{} block below.
            // However, it's not safe: the inner catch{} will be executed even it inner try{}
            // succeeds. Seems like an async/await implementation problem.
            let gradleVersionOutput = '[COULD NOT RUN gradle -v] ';
            try {
                gradleVersionOutput = yield subProcess.execute(command, ['-v'], { cwd: root });
            }
            catch (_) {
                // intentionally empty
            }
            const orange = chalk_1.default.rgb(255, 128, 0);
            const blackOnYellow = chalk_1.default.bgYellowBright.black;
            gradleVersionOutput = orange(gradleVersionOutput);
            const subProcessError = orange(error.message);
            let mainErrorMessage = `Error running Gradle dependency analysis.

Please ensure you are calling the \`snyk\` command with correct arguments.
If the problem persists, contact support@snyk.io, providing the full error
message from above, starting with ===== DEBUG INFORMATION START =====.`;
            // Special case for Android, where merging the configurations is sometimes
            // impossible.
            // There are no automated tests for this yet (setting up Android SDK is quite problematic).
            // See test/manual/README.md
            if (/Cannot choose between the following configurations/.test(error.message)
                || /Could not select value from candidates/.test(error.message)) {
                mainErrorMessage = `Error running Gradle dependency analysis.

It seems like you are scanning an Android build with ambiguous dependency variants.
We cannot automatically resolve dependencies for such builds.

We recommend converting your subproject dependency specifications from the form of
    implementation project(":mymodule")
to
    implementation project(path: ':mymodule', configuration: 'default')
or running Snyk CLI tool for a specific configuration, e.g.:
    snyk test --all-sub-projects -- --configuration=releaseRuntimeClasspath`;
            }
            const fullCommandText = 'gradle command: ' + command + ' ' + args.join(' ');
            error.message = `${blackOnYellow('===== DEBUG INFORMATION START =====')}
${orange(fullCommandText)}
${orange(gradleVersionOutput)}
${orange(error.message)}
${blackOnYellow('===== DEBUG INFORMATION END =====')}

${chalk_1.default.red.bold(mainErrorMessage)}`;
            throw error;
        }
    });
}
function getCommand(root, targetFile) {
    const isWinLocal = /^win/.test(os.platform()); // local check, can be stubbed in tests
    const quotLocal = isWinLocal ? '"' : '\'';
    const wrapperScript = isWinLocal ? 'gradlew.bat' : './gradlew';
    // try to find a sibling wrapper script first
    let pathToWrapper = path.resolve(root, path.dirname(targetFile), wrapperScript);
    if (fs.existsSync(pathToWrapper)) {
        return quotLocal + pathToWrapper + quotLocal;
    }
    // now try to find a wrapper in the root
    pathToWrapper = path.resolve(root, wrapperScript);
    if (fs.existsSync(pathToWrapper)) {
        return quotLocal + pathToWrapper + quotLocal;
    }
    return 'gradle';
}
function buildArgs(root, targetFile, gradleArgs) {
    const args = [];
    args.push('snykResolvedDepsJson', '-q');
    if (targetFile) {
        if (!fs.existsSync(path.resolve(root, targetFile))) {
            throw new Error('File not found: "' + targetFile + '"');
        }
        args.push('--build-file');
        let formattedTargetFile = targetFile;
        if (/\s/.test(targetFile)) { // checking for whitespaces
            const isWin = /^win/.test(os.platform());
            const quot = isWin ? '"' : '\'';
            formattedTargetFile = quot + targetFile + quot;
        }
        args.push(formattedTargetFile);
    }
    // For some reason, this is not required for Unix, but on Windows, without this flag, apparently,
    // Gradle process just never exits, from the Node's standpoint.
    args.push('--no-daemon');
    // Parallel builds can cause race conditions and multiple JSONDEPS lines in the output
    // Gradle 4.3.0+ has `--no-parallel` flag, but we want to support older versions.
    // Not `=false` to be compatible with 3.5.x: https://github.com/gradle/gradle/issues/1827
    args.push('-Dorg.gradle.parallel=');
    if (gradleArgs) {
        args.push(...gradleArgs);
    }
    return args;
}
exports.exportsForTests = {
    buildArgs,
    extractJsonFromScriptOutput,
};
//# sourceMappingURL=index.js.map