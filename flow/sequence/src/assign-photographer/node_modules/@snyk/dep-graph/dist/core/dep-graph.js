"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var graphlib = require("graphlib");
var DepGraphImpl = /** @class */ (function () {
    function DepGraphImpl(graph, rootNodeId, pkgs, pkgNodes, pkgManager) {
        this._countNodePathsToRootCache = new Map();
        this._graph = graph;
        this._pkgs = pkgs;
        this._pkgNodes = pkgNodes;
        this._pkgManager = pkgManager;
        this._rootNodeId = rootNodeId;
        this._rootPkgId = graph.node(rootNodeId).pkgId;
        this._pkgList = _.values(pkgs);
    }
    DepGraphImpl.getPkgId = function (pkg) {
        return pkg.name + "@" + (pkg.version || '');
    };
    Object.defineProperty(DepGraphImpl.prototype, "pkgManager", {
        get: function () {
            return this._pkgManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DepGraphImpl.prototype, "rootPkg", {
        get: function () {
            return this._pkgs[this._rootPkgId];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DepGraphImpl.prototype, "rootNodeId", {
        get: function () {
            return this._rootNodeId;
        },
        enumerable: true,
        configurable: true
    });
    DepGraphImpl.prototype.getPkgs = function () {
        return this._pkgList;
    };
    DepGraphImpl.prototype.getNodePkg = function (nodeId) {
        var node = this._graph.node(nodeId);
        if (!node) {
            throw new Error("no such node: " + nodeId);
        }
        return this._pkgs[node.pkgId];
    };
    DepGraphImpl.prototype.getPkgNodeIds = function (pkg) {
        var pkgId = DepGraphImpl.getPkgId(pkg);
        if (!this._pkgs[pkgId]) {
            throw new Error("no such pkg: " + pkgId);
        }
        return Array.from(this._pkgNodes[pkgId]);
    };
    DepGraphImpl.prototype.getNodeDepsNodeIds = function (nodeId) {
        var deps = this._graph.successors(nodeId);
        if (!deps) {
            throw new Error("no such node: " + nodeId);
        }
        return deps;
    };
    DepGraphImpl.prototype.getNodeParentsNodeIds = function (nodeId) {
        var parents = this._graph.predecessors(nodeId);
        if (!parents) {
            throw new Error("no such node: " + nodeId);
        }
        return parents;
    };
    DepGraphImpl.prototype.hasCycles = function () {
        return !graphlib.alg.isAcyclic(this._graph);
    };
    DepGraphImpl.prototype.pkgPathsToRoot = function (pkg) {
        // TODO: implement cycles support
        if (this.hasCycles()) {
            throw new Error('pkgPathsToRoot does not support cyclic graphs yet');
        }
        var pathsToRoot = [];
        for (var _i = 0, _a = this.getPkgNodeIds(pkg); _i < _a.length; _i++) {
            var id = _a[_i];
            pathsToRoot.push.apply(pathsToRoot, this.pathsFromNodeToRoot(id));
        }
        // note: sorting to get shorter paths first -
        //  it's nicer - and better resembles older behaviour
        return pathsToRoot.sort(function (a, b) { return a.length - b.length; });
    };
    DepGraphImpl.prototype.countPathsToRoot = function (pkg) {
        // TODO: implement cycles support
        if (this.hasCycles()) {
            throw new Error('countPathsToRoot does not support cyclic graphs yet');
        }
        var count = 0;
        for (var _i = 0, _a = this.getPkgNodeIds(pkg); _i < _a.length; _i++) {
            var nodeId = _a[_i];
            count += this.countNodePathsToRoot(nodeId);
        }
        return count;
    };
    DepGraphImpl.prototype.toJSON = function () {
        var _this = this;
        var nodeIds = this._graph.nodes();
        var nodes = nodeIds.reduce(function (acc, nodeId) {
            var deps = (_this._graph.successors(nodeId) || [])
                .map(function (depNodeId) { return ({ nodeId: depNodeId }); });
            acc.push({
                nodeId: nodeId,
                pkgId: _this._graph.node(nodeId).pkgId,
                deps: deps,
            });
            return acc;
        }, []);
        var pkgs = _.keys(this._pkgs)
            .map(function (pkgId) { return ({
            id: pkgId,
            info: _this._pkgs[pkgId],
        }); });
        return {
            schemaVersion: DepGraphImpl.SCHEMA_VERSION,
            pkgManager: this._pkgManager,
            pkgs: pkgs,
            graph: {
                rootNodeId: this._rootNodeId,
                nodes: nodes,
            },
        };
    };
    DepGraphImpl.prototype.pathsFromNodeToRoot = function (nodeId) {
        var _this = this;
        var parentNodesIds = this.getNodeParentsNodeIds(nodeId);
        if (parentNodesIds.length === 0) {
            return [[this.getNodePkg(nodeId)]];
        }
        var allPaths = [];
        parentNodesIds.map(function (id) {
            var out = _this.pathsFromNodeToRoot(id).map(function (path) {
                return [_this.getNodePkg(nodeId)].concat(path);
            });
            allPaths.push.apply(allPaths, out);
        });
        return allPaths;
    };
    DepGraphImpl.prototype.countNodePathsToRoot = function (nodeId) {
        var _this = this;
        if (this._countNodePathsToRootCache.has(nodeId)) {
            return this._countNodePathsToRootCache.get(nodeId);
        }
        var parentNodesIds = this.getNodeParentsNodeIds(nodeId);
        if (parentNodesIds.length === 0) {
            this._countNodePathsToRootCache.set(nodeId, 1);
            return 1;
        }
        var count = parentNodesIds.reduce(function (acc, parentNodeId) {
            return acc + _this.countNodePathsToRoot(parentNodeId);
        }, 0);
        this._countNodePathsToRootCache.set(nodeId, count);
        return count;
    };
    DepGraphImpl.SCHEMA_VERSION = '1.0.0';
    return DepGraphImpl;
}());
exports.DepGraphImpl = DepGraphImpl;
//# sourceMappingURL=dep-graph.js.map